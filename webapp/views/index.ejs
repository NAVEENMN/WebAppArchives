<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8' />
    <title>Swipe between maps</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.tiles.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js'></script>
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.3.1/mapbox-gl.js'></script>
    <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.js'></script>
    <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-compare/v0.1.0/mapbox-gl-compare.js'></script>
    <script type="text/javascript" src="/javascripts/mapboxgl-control-minimap.js"></script>
    <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.css' type='text/css'/>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.3.1/mapbox-gl.css' rel='stylesheet' />
    <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-compare/v0.1.0/mapbox-gl-compare.css' type='text/css'/>
    <link rel="stylesheet" href="/stylesheets/style.css">
  </head>
  <body>
    <div id='satellite' class='map'></div>
    <div id='streets' class='map'></div>

    <div id='cursor_info' class='map-overlay top'>
      <div class='map-overlay-inner'>
        <label>Inspection Map</label>
      </div>
    </div>

    <div class='map-overlay top'>
      <div class='map-overlay-inner'>
        <fieldset>
          <label>Inspection Map</label>
          <select id='layer' name='layer' onchange="changeLayer();" onfocus="this.selectedIndex = -1;">
            <option value='satellite'>satellite-v9</option>
            <option value='building'>streets-v11</option>
          </select>
        </fieldset>
        <label>Geometry</label>
        <text id='info'></text>
      </div>
    </div>
    <script>

      // --------------------
      mapboxgl.accessToken = 'pk.eyJ1IjoibXlzb3JuMSIsImEiOiIwODY0MDQ0ZTdiYTViYmU0ZTZiOGI4OTU5MjQxZGY1NCJ9.elqMFi4oQtFFjYXbW2Oxig';
      var metrics_points = {
        "type": "FeatureCollection",
        "features": []
      };
      // --------------------

      var satelliteMap = new mapboxgl.Map({
        container: 'satellite',
        style: 'mapbox://styles/mapbox/satellite-v9',
        center: [-74.50, 40],
        zoom: 9
      });
      var streetsMap = new mapboxgl.Map({
        container: 'streets',
        style: 'mapbox://styles/mapbox/streets-v11',
        center: [-74.50, 40],
        zoom: 9
      });

      var map = new mapboxgl.Compare(satelliteMap, streetsMap, {
        // Set this to enable comparing two maps by mouse movement:
        // mousemove: true
      });

      satelliteMap.on("style.load", function () {
        // Possible position values are 'bottom-left', 'bottom-right', 'top-left', 'top-right'
        satelliteMap.addControl(new mapboxgl.Minimap({
            center: [-74.50, 40],
            zoom: 4,
            zoomLevels: []
          }), 'bottom-left');

        satelliteMap.addControl(draw);

        satelliteMap.addSource("metrics_points", {
            "type": "geojson",
            "data": metrics_points
        });

        satelliteMap.addLayer({
          "id": "metrics-labels",
          "type": "symbol",
          "source": "metrics_points",
          "layout": {
            "text-field": ["get", "description"],
            "text-variable-anchor": ["top", "bottom", "left", "right"],
            "text-radial-offset": 0.5,
            "text-justify": "auto"
          },
          "paint":{
            "text-color": "#FFFF52",
            "text-halo-color": "#333301",
            "text-halo-width": 0.5,
            "text-halo-blur": 5
          }
        });

      });

      satelliteMap.on('draw.create', computeMetrics);
      satelliteMap.on('draw.delete', computeMetrics);
      satelliteMap.on('draw.update', computeMetrics);

      var draw = new MapboxDraw({
        displayControlsDefault: true,
        controls: {
          line_string: true,
          point: true,
          polygon: true,
          trash: true
        }
      });

      function changeLayer(obj){
        var layerId = obj.value;
        satelliteMap.setStyle('mapbox://styles/mapbox/' + layerId);
      }

      // https://turfjs.org/docs/
      function computeDistance(from_location, to_location) {
        var from = turf.point(from_location);
        var to = turf.point(to_location);
        var options = {units: 'miles'};
        // you add extra args to convert units.
        var distance = turf.distance(from, to);
        distance = Math.round(distance * 100) / 100; // rounding to 2 decimals
        distance = String(distance) + " Km";
        return distance;
      }

      function computeLength(list_of_coordinates) {
        var line = turf.lineString(list_of_coordinates);
        var length = turf.lineDistance(line);
        length = Math.round(length * 100) / 100; // rounding to 2 decimals
        length = String(length) + " Km";
        return length;
      }

      function computeArea(list_of_coordinates) {
        var area = turf.area(list_of_coordinates);
        area = Math.round(area * 100) / 100; // rounding to 2 decimals
        area = String(area) + " Sqmt";
        return area;
      }

      function constructMetricPoint(coordinate, metric) {
        obj = new Object();
        obj["type"] = "Feature";
        obj["properties"] = {"description": metric};// "icon": "for icons"
        obj["geometry"] = {"type": "Point", "coordinates": coordinate};
        return obj;
      }

      function drawMetricPoints(data_source){

      }

      function appenddistancesforsegments(coordinates, metrics_points) {
        var idx_a = 0;
        var idx_b = 0;
        for (idx_a=0,idx_b=1; idx_b<coordinates.length; idx_a++, idx_b++) {
          var distance = computeDistance(coordinates[idx_a], coordinates[idx_b]);
          var midpoint = turf.midpoint(coordinates[idx_a], coordinates[idx_b]);
          metric_point = constructMetricPoint(midpoint.geometry.coordinates, distance);
          metrics_points.features.push(metric_point);
        }
      }

      function computeMetrics(e) {
        var answer = document.getElementById('metrics');
        var data = draw.getAll();
        // remove all previous metrics
        while (metrics_points.features.length > 0) {
            metrics_points.features.pop();
        }
        // compute new metrics
        for (var i=0; i<data.features.length; i++) {
          var feature = data.features[i];
          if (feature.geometry.type == "LineString") {
            var coordinates = feature.geometry.coordinates;
            // compute distances between each segements of line
            // and append them to metrics_points
            appenddistancesforsegments(coordinates, metrics_points);
            // computer the total distance
            var length = computeLength(coordinates);
            var endpoint = coordinates[coordinates.length-1];
            metric_point = constructMetricPoint(endpoint, length);
            metrics_points.features.push(metric_point);
          } else if (feature.geometry.type == "Polygon") {
            var coordinates = feature.geometry.coordinates[0];
            // compute distances between each segements of line
            // and append them to metrics_points
            appenddistancesforsegments(coordinates, metrics_points);
            // compute the area and append it to metrics_points
            area = computeArea(feature);
            var centroid = turf.centroid(feature);
            metric_point = constructMetricPoint(centroid.geometry.coordinates, area);
            metrics_points.features.push(metric_point);
          }
        }

        drawMetricPoints(metrics_points);
        // Add a GeoJSON source containing place coordinates and information.
        satelliteMap.getSource('metrics_points').setData(metrics_points);
      }


      satelliteMap.on('click', function (e) {

      });



      satelliteMap.on('mousemove', function (e) {
        document.getElementById('info').innerHTML =
        'x: '+e.point.x+' '+'y: '+e.point.y+
        // e.point is the x, y coordinates of the mousemove event relative
        // to the top-left corner of the map
        '<br />' +
        'lat: '+e.lngLat.lat+'<br />'+
        'long: '+e.lngLat.lng
        // e.lngLat is the longitude, latitude geographical position of the event
      });



    </script>
  </body>
</html>
